package ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.services;

import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.dtos.UserResponseDTO;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.dtos.reports.*;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.entities.CategoriaEntity;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.entities.PedidoEntity;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.enums.EstadoPedido;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.repositories.CategoriaRepository;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.repositories.ItemPedidoRepository;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.repositories.PedidoRepository;
import ar.edu.utn.frc.tup.tesis.pinceletas_commerce_service.repositories.ProductoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Servicio para generación de reportes de productos y ventas.
 * Proporciona datos para dashboards administrativos.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class CommerceReportService {

    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    private final ItemPedidoRepository itemPedidoRepository;
    private final PedidoRepository pedidoRepository;

    // ============================================================
    // ========== REPORTES EXISTENTES =============================
    // ============================================================

    @Cacheable(value = "productsByCategory", unless = "#result.isEmpty()")
    public List<ProductsByCategoryReport> getProductsByCategory() {
        log.info("Generando reporte de productos por categoría");

        List<CategoriaEntity> categorias = categoriaRepository.findAll();
        List<ProductsByCategoryReport> reports = new ArrayList<>();

        for (CategoriaEntity categoria : categorias) {
            long totalProducts = categoria.getProductos() != null ? categoria.getProductos().size() : 0;
            long activeProducts = categoria.getProductos() != null ?
                    categoria.getProductos().stream().filter(p -> p.getActivo()).count() : 0;
            long inactiveProducts = totalProducts - activeProducts;

            ProductsByCategoryReport report = ProductsByCategoryReport.builder()
                    .categoryId(categoria.getId())
                    .categoryName(categoria.getNombre())
                    .totalProducts(totalProducts)
                    .activeProducts(activeProducts)
                    .inactiveProducts(inactiveProducts)
                    .build();

            reports.add(report);
        }

        log.info("Reporte de productos por categoría generado: {} categorías procesadas", reports.size());
        return reports;
    }

    @Cacheable(value = "topSellingProducts", key = "#limit", unless = "#result.isEmpty()")
    public List<TopSellingProductsReport> getTopSellingProducts(Integer limit) {
        log.info("Generando reporte de productos más vendidos (top {})", limit);

        if (limit == null || limit <= 0) {
            limit = 10;
        }

        var allItems = itemPedidoRepository.findAll();
        if (allItems.isEmpty()) {
            log.warn("No hay items de pedidos para generar el reporte");
            return new ArrayList<>();
        }

        Map<Long, TopSellingProductsReport> productSalesMap = new HashMap<>();

        for (var item : allItems) {
            Long productId = item.getProducto().getId();

            TopSellingProductsReport report = productSalesMap.getOrDefault(productId,
                    TopSellingProductsReport.builder()
                            .productId(productId)
                            .productName(item.getProducto().getNombre())
                            .categoryName(item.getProducto().getCategoria() != null ?
                                    item.getProducto().getCategoria().getNombre() : "Sin categoría")
                            .unitsSold(0L)
                            .totalRevenue(BigDecimal.ZERO)
                            .build()
            );

            BigDecimal precioConDescuento = item.getPrecioUnitario().subtract(
                    item.getPrecioUnitario().multiply(
                            item.getDescuentoPorcentaje().divide(BigDecimal.valueOf(100))
                    )
            );

            BigDecimal subtotal = precioConDescuento.multiply(BigDecimal.valueOf(item.getCantidad()));

            report.setUnitsSold(report.getUnitsSold() + item.getCantidad());
            report.setTotalRevenue(report.getTotalRevenue().add(subtotal));

            productSalesMap.put(productId, report);
        }

        List<TopSellingProductsReport> topProducts = productSalesMap.values().stream()
                .peek(report -> {
                    if (report.getUnitsSold() > 0) {
                        BigDecimal avgPrice = report.getTotalRevenue()
                                .divide(BigDecimal.valueOf(report.getUnitsSold()), 2, RoundingMode.HALF_UP);
                        report.setAveragePrice(avgPrice);
                    } else {
                        report.setAveragePrice(BigDecimal.ZERO);
                    }
                })
                .sorted((a, b) -> b.getUnitsSold().compareTo(a.getUnitsSold()))
                .limit(limit)
                .collect(Collectors.toList());

        log.info("Reporte de productos más vendidos generado: {} productos en el top", topProducts.size());
        return topProducts;
    }

    @Cacheable(value = "productGeneralStats")
    public Map<String, Long> getProductGeneralStats() {
        log.info("Generando estadísticas generales de productos");

        var allProducts = productoRepository.findAll();

        long totalProducts = allProducts.size();
        long activeProducts = allProducts.stream().filter(p -> p.getActivo()).count();
        long inactiveProducts = totalProducts - activeProducts;

        Map<String, Long> stats = new HashMap<>();
        stats.put("totalProducts", totalProducts);
        stats.put("activeProducts", activeProducts);
        stats.put("inactiveProducts", inactiveProducts);

        return stats;
    }

    @Cacheable(value = "ordersByDate", key = "#startDate + '-' + #endDate", unless = "#result.isEmpty()")
    public List<OrdersByDateReport> getOrdersByDate(LocalDate startDate, LocalDate endDate) {
        log.info("Generando reporte de pedidos por fecha - Rango: {} a {}", startDate, endDate);

        List<PedidoEntity> allPedidos;

        if (startDate == null || endDate == null) {
            LocalDate end = LocalDate.now();
            LocalDate start = end.minusDays(30);

            allPedidos = pedidoRepository.findAll().stream()
                    .filter(p -> {
                        LocalDate pedidoDate = p.getFechaCreacion().toLocalDate();
                        return !pedidoDate.isBefore(start) && !pedidoDate.isAfter(end);
                    })
                    .collect(Collectors.toList());
        } else {
            allPedidos = pedidoRepository.findAll().stream()
                    .filter(p -> {
                        LocalDate pedidoDate = p.getFechaCreacion().toLocalDate();
                        return !pedidoDate.isBefore(startDate) && !pedidoDate.isAfter(endDate);
                    })
                    .collect(Collectors.toList());
        }

        if (allPedidos.isEmpty()) {
            log.warn("No hay pedidos en el rango de fechas especificado");
            return new ArrayList<>();
        }

        Map<LocalDate, List<PedidoEntity>> pedidosPorFecha = allPedidos.stream()
                .collect(Collectors.groupingBy(p -> p.getFechaCreacion().toLocalDate()));

        List<OrdersByDateReport> reports = new ArrayList<>();

        for (Map.Entry<LocalDate, List<PedidoEntity>> entry : pedidosPorFecha.entrySet()) {
            LocalDate fecha = entry.getKey();
            List<PedidoEntity> pedidosDelDia = entry.getValue();

            long totalOrders = pedidosDelDia.size();
            BigDecimal totalRevenue = pedidosDelDia.stream()
                    .map(PedidoEntity::getTotal)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            long completedOrders = pedidosDelDia.stream()
                    .filter(p -> p.getEstado() == EstadoPedido.ENTREGADO)
                    .count();

            long cancelledOrders = pedidosDelDia.stream()
                    .filter(p -> p.getEstado() == EstadoPedido.CANCELADO ||
                            p.getEstado() == EstadoPedido.REEMBOLSADO)
                    .count();

            long pendingOrders = pedidosDelDia.stream()
                    .filter(p -> p.getEstado() == EstadoPedido.PENDIENTE ||
                            p.getEstado() == EstadoPedido.PENDIENTE_PAGO)
                    .count();

            OrdersByDateReport report = OrdersByDateReport.builder()
                    .date(fecha)
                    .totalOrders(totalOrders)
                    .totalRevenue(totalRevenue)
                    .completedOrders(completedOrders)
                    .cancelledOrders(cancelledOrders)
                    .pendingOrders(pendingOrders)
                    .build();

            reports.add(report);
        }

        reports.sort((a, b) -> b.getDate().compareTo(a.getDate()));
        log.info("Reporte de pedidos por fecha generado: {} días con pedidos", reports.size());
        return reports;
    }

    @Cacheable(value = "ordersByStatus", unless = "#result.isEmpty()")
    public List<OrdersByStatusReport> getOrdersByStatus() {
        log.info("Generando reporte de pedidos por estado");

        List<PedidoEntity> allPedidos = pedidoRepository.findAll();
        if (allPedidos.isEmpty()) {
            log.warn("No hay pedidos para generar el reporte");
            return new ArrayList<>();
        }

        long totalPedidos = allPedidos.size();

        Map<EstadoPedido, List<PedidoEntity>> pedidosPorEstado = allPedidos.stream()
                .collect(Collectors.groupingBy(PedidoEntity::getEstado));

        List<OrdersByStatusReport> reports = new ArrayList<>();

        for (Map.Entry<EstadoPedido, List<PedidoEntity>> entry : pedidosPorEstado.entrySet()) {
            EstadoPedido estado = entry.getKey();
            List<PedidoEntity> pedidosDelEstado = entry.getValue();

            long totalOrders = pedidosDelEstado.size();
            BigDecimal totalRevenue = pedidosDelEstado.stream()
                    .map(PedidoEntity::getTotal)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            double percentage = (double) totalOrders / totalPedidos * 100;

            OrdersByStatusReport report = OrdersByStatusReport.builder()
                    .status(estado.name())
                    .totalOrders(totalOrders)
                    .totalRevenue(totalRevenue)
                    .percentage(Math.round(percentage * 100.0) / 100.0)
                    .build();

            reports.add(report);
        }

        reports.sort((a, b) -> b.getTotalOrders().compareTo(a.getTotalOrders()));
        log.info("Reporte de pedidos por estado generado: {} estados", reports.size());
        return reports;
    }

    // ============================================================
    // ========== NUEVO REPORTE: COMPRAS POR USUARIO ==============
    // ============================================================

    /**
     * Genera un reporte de compras agrupadas por usuario.
     * Permite filtrar por rango de fechas opcional.
     */
    @Cacheable(value = "purchasesByUser", key = "#startDate + '-' + #endDate", unless = "#result.isEmpty()")
    public List<PurchasesByUserReport> getPurchasesByUser(LocalDate startDate, LocalDate endDate) {
        log.info("Generando reporte de compras por usuario - Rango: {} a {}", startDate, endDate);

        List<PedidoEntity> pedidos;
        if (startDate != null || endDate != null) {
            LocalDate start = startDate != null ? startDate : LocalDate.of(2000, 1, 1);
            LocalDate end = endDate != null ? endDate : LocalDate.now();

            pedidos = pedidoRepository.findAll().stream()
                    .filter(p -> {
                        LocalDate pedidoDate = p.getFechaCreacion().toLocalDate();
                        return !pedidoDate.isBefore(start) && !pedidoDate.isAfter(end);
                    })
                    .collect(Collectors.toList());
        } else {
            pedidos = pedidoRepository.findAll();
        }

        if (pedidos.isEmpty()) {
            log.warn("No hay pedidos en el rango de fechas especificado");
            return new ArrayList<>();
        }

        Map<Long, List<PedidoEntity>> pedidosPorUsuario = pedidos.stream()
                .collect(Collectors.groupingBy(PedidoEntity::getUsuarioId));

        List<PurchasesByUserReport> reports = new ArrayList<>();

        for (Map.Entry<Long, List<PedidoEntity>> entry : pedidosPorUsuario.entrySet()) {
            Long usuarioId = entry.getKey();
            List<PedidoEntity> pedidosUsuario = entry.getValue();

            try {
                UserResponseDTO usuario = obtenerInformacionUsuario(usuarioId);
                if (usuario == null) continue;

                long totalPurchases = pedidosUsuario.size();
                BigDecimal totalAmountSpent = pedidosUsuario.stream()
                        .map(PedidoEntity::getTotal)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);
                BigDecimal averageOrderAmount = totalPurchases > 0 ?
                        totalAmountSpent.divide(BigDecimal.valueOf(totalPurchases), 2, RoundingMode.HALF_UP)
                        : BigDecimal.ZERO;

                PedidoEntity ultimoPedido = pedidosUsuario.stream()
                        .max(Comparator.comparing(PedidoEntity::getFechaCreacion))
                        .orElse(null);

                PurchasesByUserReport report = PurchasesByUserReport.builder()
                        .userId(usuarioId)
                        .userName(usuario.getNombre() + " " + usuario.getApellido())
                        .userEmail(usuario.getEmail())
                        .totalPurchases(totalPurchases)
                        .totalAmountSpent(totalAmountSpent)
                        .averageOrderAmount(averageOrderAmount)
                        .lastPurchaseDate(ultimoPedido != null ? ultimoPedido.getFechaCreacion() : null)
                        .lastOrderStatus(ultimoPedido != null ? ultimoPedido.getEstado().name() : null)
                        .build();

                reports.add(report);

            } catch (Exception e) {
                log.error("Error procesando usuario ID {}: {}", usuarioId, e.getMessage());
            }
        }

        reports.sort((a, b) -> b.getTotalAmountSpent().compareTo(a.getTotalAmountSpent()));
        log.info("Reporte de compras por usuario generado: {} usuarios procesados", reports.size());
        return reports;
    }

    private UserResponseDTO obtenerInformacionUsuario(Long usuarioId) {
        try {
            String url = "http://localhost:8081/api/users/by-id/" + usuarioId;

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            HttpEntity<String> entity = new HttpEntity<>(headers);

            ResponseEntity<UserEmailInfo> response = new RestTemplate().exchange(
                    url,
                    HttpMethod.GET,
                    entity,
                    UserEmailInfo.class
            );

            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                UserEmailInfo info = response.getBody();

                UserResponseDTO userResponse = new UserResponseDTO();
                userResponse.setId(info.id());
                userResponse.setEmail(info.email());
                userResponse.setNombre(info.nombre());
                userResponse.setApellido(info.apellido());
                return userResponse;
            }
        } catch (Exception e) {
            log.error("Error obteniendo información de usuario {}: {}", usuarioId, e.getMessage());
        }
        return null;
    }

    private record UserEmailInfo(Long id, String email, String nombre, String apellido) {}
}
